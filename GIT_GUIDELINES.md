# Git & GitHub 워크플로우 가이드라인

이 문서는 Git과 GitHub를 사용한 프로젝트 관리 및 협업을 위한 표준 가이드라인을 제공합니다. 일관성 있는 워크플로우를 통해 프로젝트 히스토리를 명확하게 유지하고 협업 효율성을 높이는 것을 목표로 합니다.

## 1. 원격 저장소 (Remote Repository) 설정

새로운 프로젝트를 시작할 때, 다음 절차에 따라 GitHub 원격 저장소를 생성하고 로컬 환경과 연결합니다.

### 1.1. GitHub CLI (`gh`) 설치 확인 및 설치

터미널에서 `gh --version` 명령어를 실행하여 `gh`가 설치되어 있는지 확인합니다. 만약 설치되어 있지 않다면, Homebrew (macOS) 또는 다른 패키지 매니저를 사용하여 설치합니다.

```bash
# 설치 확인
gh --version

# Homebrew로 설치 (macOS)
brew install gh
```

### 1.2. GitHub 인증

`gh`가 로컬 환경에서 당신의 GitHub 계정에 접근할 수 있도록 인증 절차를 진행합니다. 이 과정은 웹 브라우저를 통해 완료됩니다.

```bash
gh auth login
```

### 1.3. 저장소 생성 및 로컬 프로젝트 연결

로컬 프로젝트 디렉토리에서 다음 명령어를 실행하여 Git을 초기화하고, GitHub에 새로운 원격 저장소를 생성하며, 로컬 저장소를 원격에 연결합니다.

```bash
# 1. 로컬 Git 저장소 초기화
git init

# 2. GitHub에 원격 저장소 생성 및 연결
# <repository-name>을 실제 프로젝트 이름으로 변경하세요.
# --public 또는 --private 플래그를 사용하여 공개 범위를 설정합니다.
gh repo create <repository-name> --public --source=. --remote=origin
```

### 1.4. 초기 파일 푸시

프로젝트의 초기 파일들을 원격 저장소에 푸시합니다.

```bash
git add .
git commit -m "Initial commit"
git push -u origin main
```

## 2. 커밋 메시지 컨벤션

프로젝트의 모든 커밋 메시지는 **한글**로 작성하는 것을 원칙으로 하며, **Conventional Commits** 명세에 따라 구성합니다. 이는 커밋 히스토리의 가독성을 높이고, 변경 사항을 쉽게 추적하며, 버전 관리를 자동화하는 데 도움이 됩니다.

### 2.1. 커밋 메시지 구조

```
<타입>(<스코프>): <제목>
<본문>
<꼬리말>
```

-   **타입 (type)**: 커밋의 종류를 나타냅니다. (필수)
-   **스코프 (scope)**: 커밋이 영향을 미치는 범위를 나타냅니다. (선택, 예: `auth`, `profile`)
-   **제목 (subject)**: 커밋에 대한 짧은 요약 설명입니다. (필수)
-   **본문 (body)**: 커밋에 대한 자세한 설명이 필요할 경우 작성합니다. (선택)
-   **꼬리말 (footer)**: 이슈 트래커 ID 등 추가적인 메타데이터를 포함합니다. (선택, 예: `Fixes: #123`)

### 2.2. 주요 커밋 타입 (`type`)

-   **feat**: 새로운 기능 추가
-   **fix**: 버그 수정
-   **docs**: 문서 변경 (README, 가이드라인 등)
-   **style**: 코드 스타일 변경 (포맷팅, 세미콜론 추가 등; 로직 변경 없음)
-   **refactor**: 코드 리팩토링 (기능 추가나 버그 수정 없는 코드 구조 변경)
-   **test**: 테스트 코드 추가 또는 수정
-   **chore**: 빌드 프로세스, 패키지 매니저 설정 등 기타 변경
-   **ci**: CI/CD 관련 설정 변경
-   **perf**: 성능 개선

### 2.3. 커밋 메시지 작성 규칙

-   제목은 **명령문**으로, **동사 원형**으로 시작합니다. (예: `추가함`, `수정함`이 아닌 `추가`, `수정`)
-   제목의 길이는 50자를 넘지 않도록 간결하게 작성합니다.
-   본문은 어떻게(how) 보다는 **무엇을(what) 왜(why)** 변경했는지 위주로 설명합니다.

### 2.4. 커밋 메시지 예시

**예시 1: 새로운 기능 추가**

```
feat(auth): 사용자 로그인 기능 추가

- POST /api/login 엔드포인트 구현
- 로그인 성공 시 JWT 토큰 생성 로직 추가
```

**예시 2: 버그 수정**

```
fix(profile): 프로필 이미지 표시 오류 수정

대시보드에서 프로필 이미지가 잘못된 URL 경로로 인해 렌더링되지 않던 문제를 해결합니다.
경로 생성 로직을 올바르게 수정했습니다.

Fixes: #123
```

**예시 3: 문서만 변경**

```
docs(readme): 프로젝트 초기 설정 방법 업데이트
```

### 2.5. 커밋 단위 (Commit Unit)

커밋은 **작고 논리적인 하나의 작업 단위**로 구성하는 것을 원칙으로 합니다. 이는 코드 리뷰를 용이하게 하고, 문제 발생 시 특정 변경 사항을 추적하고 되돌리는 작업을 단순화합니다.

-   **원자성 (Atomic)**: 하나의 커밋은 하나의 문제 해결 또는 하나의 기능 개발과 같이 단일 목적을 가져야 합니다. 예를 들어, 버그 수정과 새로운 기능 추가를 하나의 커밋에 포함해서는 안 됩니다.
-   **기능적 분리**: 큰 기능을 개발할 때는 여러 개의 작은 커밋으로 분리하여 진행합니다. 예를 들어, '사용자 인증 기능 구현'이라는 큰 작업은 아래와 같이 여러 커밋으로 나눌 수 있습니다.
    1.  `feat(auth): User 모델 및 데이터베이스 스키마 추가`
    2.  `feat(auth): 회원가입 API 엔드포인트 구현`
    3.  `feat(auth): 로그인 및 JWT 발급 기능 구현`
    4.  `test(auth): 인증 관련 테스트 코드 작성`
-   **리팩토링과 기능 변경 분리**: 코드 리팩토링과 기능적인 변경(버그 수정, 기능 추가)은 반드시 별개의 커밋으로 분리해야 합니다.

## 3. 브랜칭 전략 (Branching Strategy)

기능 개발, 버그 수정 등 모든 작업은 별도의 브랜치에서 진행하는 것을 원칙으로 합니다.

1.  **`main` (또는 `master`) 브랜치**: 항상 안정적이고 배포 가능한 상태를 유지합니다. 직접적인 커밋은 금지합니다.
2.  **기능 브랜치**: 새로운 기능을 개발할 때 사용합니다. `main` 브랜치에서 분기하며, 이름은 `feat/` 접두사를 사용합니다. (예: `feat/user-signup`)
3.  **수정 브랜치**: 버그를 수정할 때 사용합니다. `main` 브랜치에서 분기하며, 이름은 `fix/` 접두사를 사용합니다. (예: `fix/login-error`)

작업이 완료되면 Pull Request (PR)를 통해 `main` 브랜치로 병합합니다.
